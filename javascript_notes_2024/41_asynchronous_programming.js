
    // Synchronous code example
    // Global Execution Context
    console.log("Start of synchronous code execution");
    function middle(){
        console.log("Step 2");
        console.log("Step 3");
    }
    middle(); 
    console.log("End of synchronous code execution");

    // Synchronous function definition within the global context
    function logger(){
        console.log("Step 2");
        // Function Execution Context: This function is called within the logger function execution context
        function finish(){
            console.log("Finishing up");
        }
        // Synchronous function call within the logger function execution context
        finish(); 
        console.log("Step 3");
    }
    logger();

    var a = {
    index: 1
    };
    // later
    console.log( a ); // ??
    // even later
    a.index++;

    // Asynchronous code example
    function middle(){
        console.log("Step 3");
        console.log("Step 4");
    }
    console.log("Start of asynchronous code");
    // setTimeout function simulating asynchronous operation
    setTimeout(middle, 2000);  // Browser Web APIs manage this setTimeout function
    console.log("End of asynchronous code");

    // Global Execution Context
    console.log("Message");
    logger();
    console.log(1);
    function logger(){
        console.log(2);
        // Synchronous function call within the logger function execution context
        finish();
        console.log(3);
    }
    // Global Execution Context
    function finish(){
        console.log("Finish")
    }

//The call stack in JavaScript functions like a stack of trays in a cafeteria. It manages the execution order of functions: adding a tray when a function is called and removing it when the function completes. As JavaScript is single-threaded, the call stack ensures that functions are executed sequentially, preventing concurrency issues.
//The event loop acts as the kitchen manager, overseeing the call stack and the callback queue. When the call stack is empty, it moves tasks from the callback queue to the stack for execution. This allows JavaScript to manage asynchronous tasks efficiently without blocking the main thread, ensuring responsiveness in applications.
//Web APIs serve as kitchen appliances or tools for JavaScript to handle specific tasks asynchronously, such as timers (setTimeout, setInterval), DOM manipulation, and AJAX requests (fetch). When asynchronous functions are called, they are delegated to the browser's Web APIs for processing. After completing their tasks, like fetching data, Web APIs enqueue a callback function in the callback queue for subsequent execution in the event loop.
//The callback queue is a storage area for callback functions generated by completed asynchronous tasks. These callbacks await their turn in the queue until the call stack is empty. When the call stack clears, the event loop transfers callbacks from the queue to the stack for execution, ensuring proper handling of asynchronous operations in JavaScript.

